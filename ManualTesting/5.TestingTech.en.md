# Testing Techniques
Testing techniques are specific methods to perform testing, helping to detect errors effectively. Below are common techniques, often applied depending on the phase and type of project (e.g., in Agile or Waterfall).
1. **Smoke Testing**:
    - Performed after a new build to check the basic stability of the system.
    - Focuses on critical paths to determine if the build has errors.
    - **Advantages**: Quick, time-saving; **Disadvantages**: Not in-depth, only surface-level checks.
    - **Example**: After code update, quickly test if login and homepage load.

2. **Sanity Testing**:
    - Checks the rationality of the software based on fixed bugs and newly added features.
    - Confirms that changes do not negatively affect the system.
    - **Example**: After fixing payment bug, test if the new payment function works correctly.
    - *Often a subset of Regression Testing, used in the final build phase.*

3. **Confirmation Testing (Re-Testing)**:
    - Retests failed test cases after fixes, ensuring no new errors arise.
    - Focuses on specific reported errors.
    - **Example**: Retest registration test case that failed before â†’ After dev fixes.
    - *Helps confirm successful fixes, often manual or automated*

4. **Regression Testing**:
    - Retests old functions or the entire system to ensure it runs okay after changes (new code, bug fixes).
    - Prevents recurring errors or new errors from changes.
    - **Example**: After adding chat feature, retest the entire app to see if login is affected.
    - *Often uses automation tools like Selenium; Advantages: Ensures stability; Disadvantages: Time-consuming if manual.*

5. **Ad-Hoc Testing**:
    - Based on experience, without plans or documents, aiming to find unexpected system errors.
    - Tester freely "breaks" the system based on intuition.
    - **Example**: Try inputting strange data (SQL injection) without following test cases.
    - *Suitable when time is limited; **Disadvantages**: Not systematic, hard to reproduce.*

6. **Exploratory Testing**:
    - Testing process without special plans or schedules, tester learns and designs tests simultaneously.
    - Based on initial test cases, designs random tests on the system to discover errors.
    - **Example**: Explore a new app by trying different user flows (like multi-tab, offline).

7. **Compatibility Testing**:
    - Tests compatibility of the application with different environments, platforms (browser, OS, device).
    - Ensures the app runs well on multiple devices.
    - **Example**: Test web app on Chrome, Firefox, iOS, Android.

8. **Maintenance Testing**:
    - Testing on the operating and in-use system, after release.
    - Focuses on maintenance, updates, and fixing user issues.
    - **Example**: Test after server update to ensure no downtime.


*These techniques can be combined, e.g., Smoke + Sanity for new builds, Regression for each release. In Agile, prioritize automation for speed*

# Defect Life Cycle
- A set of states that a bug/defect goes through from discovery to closure.
- Helps manage bugs systematically, track fix progress.
- **Common States**:
    1. **New/Open**: New bug reported.
    2. **Assigned**: Assigned to dev for fix.
    3. **In Progress**: Being fixed.
    4. **Fixed/Resolved**: Fixed, awaiting verification.
    5. **Reopened**: If verification fails, reopen.
    6. **Verified**: Tester confirms fix okay.
    7. **Closed**: Bug fully resolved.

# Bug Report
A detailed document about errors found in the software application, helping devs understand and fix quickly.
**Contains the following information:**
|Information|Description|
|-|-|
|Defect ID|Unique bug code (auto-generated).|
|Description|Detailed bug description (what happened, expected vs actual).|
|Version|Software version where the error occurred.|
|Steps|Steps to reproduce the error (step-by-step).|
|Created Date|Report creation date.|
|File|Attached