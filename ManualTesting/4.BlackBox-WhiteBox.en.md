# Introduction
- **Black-box testing**: Focuses on input and output, without concern for the internal code. Suitable for testers without deep programming knowledge, often used at System Testing and UAT levels.
- **White-box testing**: Testers examine the internal code structure to check logic and paths. Suitable for developers, often used at Unit and Integration Testing levels.

|Criteria|Black Box|White Box|
|-|-|-|
|Focus|Function, requirements|Code, internal logic|
|Required knowledge|User requirements|Source code, programming|
|Advantages|Simple, close to reality|Early error detection|
|Disadvantages|Does not detect deep errors|Time-consuming, requires code|

# Black-Box Testing
This testing assumes the system as a sealed "black box," only checking external behavior. Prioritizes designing test cases based on requirements.
### Main Techniques
1. **Equivalence Partitioning**:
    - Divide input into equivalent regions (valid/invalid), where values in a region produce the same output.
    - Test only one representative per region to save time.
    - **Example**: Age input field (18-60). Regions: <18 (invalid), 18-60 (valid), >60 (invalid). Test: 17, 30, 61.

2. **Boundary Value Analysis**:
    - Test boundary values (edges) of equivalent classes, as errors often occur there.
    - **Example**: For age 18-60, test: 17 (lower invalid boundary), 18 (lower valid boundary), 60 (upper valid boundary), 61 (upper invalid boundary).
3. **Decision Table Testing**:
    - List all combinations of inputs and expected outputs to check logic.
    - Example: Login

|Username|Password|Output|
|-|-|-|
|Correct|Correct|Login successful|
|Correct|Incorrect|Password error|
|Incorrect|Correct|Username error|
|Incorrect|Incorrect|Both errors|

4. **Error Guessing**:
    - Based on experience to predict and test potential errors from previous projects.
    - Example: Test special inputs like strange characters, negative numbers, or weak network cases.
5. **State Transition Testing**:
    - Check state changes according to events.
    - **Example**: Login system:

|Initial State|Event|New State|
|-|-|-|
|Logout|Enter correct user/pass|Login|
|Login|Press logout|Logout|
|Login|Incorrect pass 3 times|Account locked|

6. **Exploratory Testing:**
- Not following a fixed script, testers freely explore based on understanding and experience.
- When to use:
    - Incomplete documentation.
    - Want to detect creative, hidden errors.
- **Example**: Use the app like a real user, try unexpected operations (quick back/forward).

# White-Box Testing
This testing "opens the box" to view the internal code, ensuring all paths and logic are checked.
### Main Techniques
1. **Basis Path Testing - Control Flow Graph**:
    - Draw a control flow graph of the code to test all independent paths.
    - **Example**: For an if-else function, test true and false paths to cover 100% code.

2. **Control Flow Testing**:
    - Check structures like if-else, loop, switch.
    - **Example**: Test a for loop from 0 to n, ensure no infinite loop.

3. **Data Flow Testing**:
    - Track variables (define-use-kill): Definition, use, kill.
    - **Example**: Variable x assigned on line 1, used on line 5 â†’ Check no use of uninitialized variable.

4. **Mutation Testing**:
    - Change code (mutants, example: + to -) to see if test cases "kill" (detect) the mutant.
    - **Example**: If test cases do not detect the change, need to improve the test suite.