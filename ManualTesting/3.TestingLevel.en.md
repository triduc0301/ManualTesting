# Testing Levels
Testing levels represent different levels in the testing process, from detailed to overall, helping to detect errors at each layer. Below are the 4 main levels (often according to the V-Model or Agile model).

### 1. Unit Testing:
- Usually handled by developers (dev), checking individual modules, functions, methods, classes.
- Falls within the scope of white-box testing: Checking the internal code of the system to evaluate code standards, performance, resource usage.
- Cannot find all application errors (only focuses on small units).

### 2. Integration Testing:
- Testing interactions between functions/modules.
- Example: Register account â†’ Login to the system; check if data is transmitted correctly between modules.


### 3. System Testing:
- Belongs to black-box testing scope: Only concerned with input and expected output, without knowing the internal code.
- Requires abilities:
    - Determine pre- and post-test requirements (pre- and post-conditions).
    - Determine complexity for each test function.
    - Determine impact on the system.

- Some types of testing under System Testing:
    - Functional testing: Ensure operation according to requirements.
    - Performance testing: According to performance requirements (speed, load).


### 4. User Acceptance Testing (UAT):
- Check if the system meets customer needs and expectations.
- Alpha Testing: Users test the software at the development site (dev/test environment).
- Beta Testing: Send the product to end-users for testing in real environments; collect error feedback to return to dev for fixes.

<i>These levels are usually performed in order, but in Agile, they can be repeated in each sprint.</i>

# Testing Methods
Testing methods are divided into two main types: functional and non-functional, focusing on different aspects of the software.
### Functional Testing
- Is a type of black-box testing.
- Testing by entering input and checking, evaluating output without concern for the internal structure or installation of the application.

**Typically includes 6 steps:**
1. Identify the functions that the software is expected to perform (based on SRS).
2. Determine the input data set based on the function's technical specifications.
3. Determine the output data set based on the function's technical specifications.
4. Write and execute test cases.
5. Compare the output results from step 3 with the actual results.
6. Based on customer needs to evaluate if the results from step 5 are suitable or not.

**Functional testing classification:**
1. **Function Testing**: Check if each individual function works correctly (example: does the "Submit" button send the form?).
2. **User Interface Testing**: Check the product's UI (example: responsive layout on mobile/desktop).
3. **Data & Database Integrity Testing**:
    - Database operations (example: is the SQL query correct?).
    - Correctness of data storage (example: data is not lost or distorted).

4. **Business Cycle Testing**: Ensure functions operate according to project requirements (example: purchasing process from cart to payment).
5. **Access Control Testing**: Ensure system access process according to permissions (example: regular users cannot access admin panel).

# Non-Functional Testing
Focuses on aspects not related to specific functions, such as performance, security, usability.

**Non-functional testing classification:**
1. **Performance Testing**: Performance testing to determine system speed, evaluated through 5 criteria:
    - Response time (response time: time to process request).
    - Scalability (Scalability: system handles gradual load increase).
    - Throughput (Throughput: number of transactions per second).
    - Stability (Stability: no crash under high load).
    - Software speed (Speed: total time to complete task).
2. **Load Testing**: Test by continuously increasing load to the threshold limit (example: 1000 users accessing simultaneously).
3. **Stress Testing**: Test when exceeding the maximum threshold, how the system behaves and recovers (example: overload server to see if it auto-recovers).
4. **Volume Testing**: Analyze performance by increasing data volume in the database (example: insert 1 million records and check query time).